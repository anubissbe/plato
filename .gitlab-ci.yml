# GitLab CI/CD Pipeline Configuration for Plato

# Define stages
stages:
  - build
  - test
  - quality
  - deploy

# Cache node_modules between jobs
cache:
  paths:
    - node_modules/
    - .npm/

# Default settings for all jobs
default:
  image: node:20-alpine
  before_script:
    - npm ci --cache .npm --prefer-offline

# Variables
variables:
  NODE_ENV: "production"
  AUTO_DEVOPS_ENABLED: "true"

# Build stage
build:
  stage: build
  script:
    - npm run build
    - echo "Build completed successfully"
  artifacts:
    paths:
      - dist/
    expire_in: 1 week

# Test stage
test:unit:
  stage: test
  script:
    - npm test -- --coverage --maxWorkers=2
    - echo "Unit tests completed"
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
    expire_in: 1 week

# TypeScript type checking
test:typecheck:
  stage: test
  script:
    - npm run typecheck
    - echo "Type checking completed"

# Linting
quality:lint:
  stage: quality
  script:
    - npm run lint
    - echo "Linting completed"
  allow_failure: true

# Security scanning
security:dependencies:
  stage: quality
  script:
    - npm audit --audit-level=moderate
    - echo "Security audit completed"
  allow_failure: true

# Performance testing
quality:performance:
  stage: quality
  script:
    - npm run build
    - echo "Checking bundle size..."
    - du -sh dist/
    - echo "Performance checks completed"

# Deploy to staging (manual trigger)
deploy:staging:
  stage: deploy
  script:
    - echo "Deploying to staging environment..."
    - npm run build
    - echo "Deployment to staging completed"
  environment:
    name: staging
    url: https://staging.plato.example.com
  when: manual
  only:
    - main
    - develop

# Deploy to production (manual trigger, main branch only)
deploy:production:
  stage: deploy
  script:
    - echo "Deploying to production environment..."
    - npm run build
    - echo "Deployment to production completed"
  environment:
    name: production
    url: https://plato.example.com
  when: manual
  only:
    - main

# Auto DevOps features are integrated directly in this file
# instead of including the template to avoid conflicts

# Container scanning (optional, requires Docker registry)
container_scanning:
  stage: quality
  image: registry.gitlab.com/gitlab-org/security-products/analyzers/klar:latest
  variables:
    GIT_STRATEGY: fetch
    DOCKER_IMAGE: "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"
  script:
    - echo "Container scanning would run here if Docker registry is configured"
  allow_failure: true
  rules:
    - if: '$CI_REGISTRY_IMAGE && $CI_COMMIT_BRANCH == "main"'
      when: always
    - when: manual

# SAST (Static Application Security Testing)
sast:
  stage: quality
  image: registry.gitlab.com/gitlab-org/security-products/analyzers/nodejs-scan:latest
  script:
    - echo "Running security analysis..."
    - npm audit --audit-level=low || true
  allow_failure: true
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always
    - when: manual

# Code quality analysis
code_quality:
  stage: quality
  image: node:20-alpine
  script:
    - echo "Running code quality checks..."
    - npm run lint || true
  allow_failure: true
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always
    - when: manual

# Kubernetes deployment (optional, requires cluster configuration)
# These jobs are placeholders for when Kubernetes cluster is connected
# To enable: Configure Kubernetes cluster in GitLab project settings

# Review app deployment placeholder
review_app:
  stage: deploy
  image: alpine:latest
  script:
    - echo "Review app deployment would run here if Kubernetes cluster is configured"
    - echo "To enable: Settings -> Infrastructure -> Kubernetes clusters"
  environment:
    name: review/$CI_COMMIT_REF_NAME
    url: https://review-$CI_COMMIT_REF_SLUG.plato.example.com
    on_stop: stop_review_app
  rules:
    - if: '$CI_KUBERNETES_ACTIVE == "true" && $CI_COMMIT_BRANCH != "main"'
      when: manual
  allow_failure: true
  when: manual

stop_review_app:
  stage: deploy
  image: alpine:latest
  script:
    - echo "Stopping review app..."
  environment:
    name: review/$CI_COMMIT_REF_NAME
    action: stop
  dependencies: []
  when: manual
  allow_failure: true
  rules:
    - if: '$CI_KUBERNETES_ACTIVE == "true" && $CI_COMMIT_BRANCH != "main"'
      when: manual