/**
 * Analytics Service Tests
 * 
 * Comprehensive tests for CostCalculator and AnalyticsManager classes
 * covering cost calculation, data persistence, and performance requirements
 */

import { describe, test, expect, jest, beforeEach, afterEach } from '@jest/globals';
import fs from 'fs/promises';
import path from 'path';

// Mock fs operations
jest.mock('fs/promises');
const mockFs = fs as jest.Mocked<typeof fs>;

// Import types that will be implemented
interface CostMetric {
  timestamp: number;
  sessionId: string;
  model: string;
  inputTokens: number;
  outputTokens: number;
  cost: number;
  provider: 'copilot' | 'openai' | 'claude';
  command?: string;
  duration: number;
}

interface AnalyticsSummary {
  period: 'day' | 'week' | 'month';
  startDate: number;
  endDate: number;
  totalCost: number;
  totalTokens: number;
  sessionCount: number;
  avgCostPerSession: number;
  modelBreakdown: Record<string, { cost: number; tokens: number }>;
}

interface AnalyticsManagerOptions {
  dataDir?: string;
  autoSave?: boolean;
  saveInterval?: number;
  retentionMonths?: number;
}

// Import the classes that will be implemented
let CostCalculator: any;
let AnalyticsManager: any;

// Mock the imports before the actual implementation exists
try {
  const analyticsModule = require('../analytics');
  CostCalculator = analyticsModule.CostCalculator;
  AnalyticsManager = analyticsModule.AnalyticsManager;
} catch {
  // Classes don't exist yet - define mock classes for testing
  class MockCostCalculator {
    private static readonly PRICING = {
      'copilot': { input: 0.000002, output: 0.000008 },
      'gpt-4': { input: 0.00003, output: 0.00006 },
      'claude-3': { input: 0.000015, output: 0.000075 }
    };

    calculateCost(provider: string, model: string, inputTokens: number, outputTokens: number): number {
      const pricing = MockCostCalculator.PRICING[provider as keyof typeof MockCostCalculator.PRICING];
      if (!pricing) return 0;
      return (inputTokens * pricing.input) + (outputTokens * pricing.output);
    }

    updatePricing(provider: string, pricing: { input: number; output: number }): void {
      // Mock implementation
    }
  }

  class MockAnalyticsManager {
    private options: Required<AnalyticsManagerOptions>;
    private dataStore: Map<string, CostMetric[]> = new Map();

    constructor(options: AnalyticsManagerOptions = {}) {
      this.options = {
        dataDir: options.dataDir || '.plato/analytics',
        autoSave: options.autoSave !== false,
        saveInterval: options.saveInterval || 30000,
        retentionMonths: options.retentionMonths || 6,
      };
    }

    async recordMetric(metric: CostMetric): Promise<void> {
      // Mock implementation
    }

    async getMetrics(startDate: number, endDate: number): Promise<CostMetric[]> {
      return [];
    }

    async getSummary(period: 'day' | 'week' | 'month'): Promise<AnalyticsSummary> {
      return {
        period,
        startDate: 0,
        endDate: 0,
        totalCost: 0,
        totalTokens: 0,
        sessionCount: 0,
        avgCostPerSession: 0,
        modelBreakdown: {}
      };
    }

    async exportData(format: 'csv' | 'json', dateRange?: [number, number]): Promise<string> {
      return format === 'csv' ? 'timestamp,cost' : '[]';
    }

    async cleanup(): Promise<void> {
      // Mock implementation
    }

    async initialize(): Promise<void> {
      // Mock implementation
    }
  }

  CostCalculator = MockCostCalculator;
  AnalyticsManager = MockAnalyticsManager;
}

describe('CostCalculator', () => {
  let calculator: any;

  beforeEach(() => {
    calculator = new CostCalculator();
  });

  describe('calculateCost', () => {
    test('should calculate correct cost for Copilot', () => {
      const cost = calculator.calculateCost('copilot', 'gpt-3.5-turbo', 1000, 500);
      // Expected: (1000 * 0.000002) + (500 * 0.000008) = 0.002 + 0.004 = 0.006
      expect(cost).toBe(0.006);
    });

    test('should calculate correct cost for GPT-4', () => {
      const cost = calculator.calculateCost('gpt-4', 'gpt-4', 1000, 500);
      // Expected: (1000 * 0.00003) + (500 * 0.00006) = 0.03 + 0.03 = 0.06
      expect(cost).toBe(0.06);
    });

    test('should calculate correct cost for Claude-3', () => {
      const cost = calculator.calculateCost('claude-3', 'claude-3-sonnet', 1000, 500);
      // Expected: (1000 * 0.000015) + (500 * 0.000075) = 0.015 + 0.0375 = 0.0525
      expect(cost).toBe(0.0525);
    });

    test('should return 0 for unknown provider', () => {
      const cost = calculator.calculateCost('unknown', 'model', 1000, 500);
      expect(cost).toBe(0);
    });

    test('should handle zero tokens', () => {
      const cost = calculator.calculateCost('copilot', 'gpt-3.5-turbo', 0, 0);
      expect(cost).toBe(0);
    });

    test('should handle large token counts', () => {
      const cost = calculator.calculateCost('copilot', 'gpt-3.5-turbo', 100000, 50000);
      // Expected: (100000 * 0.000002) + (50000 * 0.000008) = 0.2 + 0.4 = 0.6
      expect(cost).toBe(0.6);
    });
  });

  describe('updatePricing', () => {
    test('should allow updating pricing for existing providers', () => {
      const newPricing = { input: 0.000001, output: 0.000004 };
      calculator.updatePricing('copilot', newPricing);
      
      const cost = calculator.calculateCost('copilot', 'gpt-3.5-turbo', 1000, 500);
      // Expected: (1000 * 0.000001) + (500 * 0.000004) = 0.001 + 0.002 = 0.003
      expect(cost).toBe(0.003);
    });
  });
});

// Define mock metric at the top level for use across all test blocks
const mockMetric: CostMetric = {
  timestamp: Date.now(),
  sessionId: 'session-123',
  model: 'gpt-3.5-turbo',
  inputTokens: 100,
  outputTokens: 50,
  cost: 0.002,
  provider: 'copilot',
  duration: 1500
};

describe('AnalyticsManager', () => {
  let manager: any;
  let testDataDir: string;

  beforeEach(() => {
    jest.useFakeTimers();
    jest.clearAllMocks();
    
    testDataDir = '.plato/analytics-test';
    manager = new AnalyticsManager({ 
      dataDir: testDataDir,
      autoSave: false 
    });

    // Setup fs mocks
    mockFs.access.mockResolvedValue();
    mockFs.mkdir.mockResolvedValue(undefined);
    mockFs.readFile.mockResolvedValue('[]');
    mockFs.writeFile.mockResolvedValue();
    mockFs.readdir.mockResolvedValue([]);
  });

  afterEach(() => {
    jest.useRealTimers();
    jest.clearAllMocks();
  });

  describe('initialization', () => {
    test('should initialize with default options', () => {
      const defaultManager = new AnalyticsManager();
      expect(defaultManager).toBeInstanceOf(AnalyticsManager);
    });

    test('should use custom options', () => {
      const customManager = new AnalyticsManager({
        dataDir: '/custom/path',
        autoSave: false,
        retentionMonths: 12
      });
      expect(customManager).toBeInstanceOf(AnalyticsManager);
    });

    test('should create data directory on initialize', async () => {
      mockFs.access.mockRejectedValueOnce(new Error('ENOENT'));
      
      await manager.initialize();
      
      expect(mockFs.mkdir).toHaveBeenCalledWith(testDataDir, { recursive: true });
    });
  });

  describe('recordMetric', () => {

    test('should record a new metric', async () => {
      await manager.recordMetric(mockMetric);
      
      // Should be stored in memory
      const metrics = await manager.getMetrics(0, Date.now() + 1000);
      expect(metrics).toContainEqual(mockMetric);
    });

    test('should batch multiple metrics for performance', async () => {
      const metrics = Array.from({ length: 5 }, (_, i) => ({
        ...mockMetric,
        timestamp: Date.now() + i,
        sessionId: `session-${i}`
      }));

      for (const metric of metrics) {
        await manager.recordMetric(metric);
      }

      // Should batch writes for performance
      const allMetrics = await manager.getMetrics(0, Date.now() + 1000);
      expect(allMetrics).toHaveLength(5);
    });

    test('should handle invalid metrics gracefully', async () => {
      const invalidMetric = { ...mockMetric, cost: -1 };
      
      await expect(manager.recordMetric(invalidMetric)).rejects.toThrow();
    });
  });

  describe('getMetrics', () => {
    test('should return metrics within date range', async () => {
      const startDate = new Date('2025-01-01').getTime();
      const endDate = new Date('2025-01-31').getTime();
      
      const metrics = await manager.getMetrics(startDate, endDate);
      
      expect(Array.isArray(metrics)).toBe(true);
      // All returned metrics should be within range
      metrics.forEach((metric: CostMetric) => {
        expect(metric.timestamp).toBeGreaterThanOrEqual(startDate);
        expect(metric.timestamp).toBeLessThanOrEqual(endDate);
      });
    });

    test('should return empty array when no metrics match range', async () => {
      const startDate = new Date('2030-01-01').getTime();
      const endDate = new Date('2030-01-31').getTime();
      
      const metrics = await manager.getMetrics(startDate, endDate);
      
      expect(metrics).toEqual([]);
    });

    test('should complete within performance requirements (<200ms)', async () => {
      const startTime = Date.now();
      await manager.getMetrics(0, Date.now());
      const duration = Date.now() - startTime;
      
      expect(duration).toBeLessThan(200);
    });
  });

  describe('getSummary', () => {
    test('should generate daily summary', async () => {
      const summary = await manager.getSummary('day');
      
      expect(summary.period).toBe('day');
      expect(summary).toHaveProperty('totalCost');
      expect(summary).toHaveProperty('totalTokens');
      expect(summary).toHaveProperty('sessionCount');
      expect(summary).toHaveProperty('avgCostPerSession');
      expect(summary).toHaveProperty('modelBreakdown');
    });

    test('should generate weekly summary', async () => {
      const summary = await manager.getSummary('week');
      
      expect(summary.period).toBe('week');
      expect(typeof summary.totalCost).toBe('number');
      expect(typeof summary.totalTokens).toBe('number');
    });

    test('should generate monthly summary', async () => {
      const summary = await manager.getSummary('month');
      
      expect(summary.period).toBe('month');
      expect(summary.modelBreakdown).toBeDefined();
    });

    test('should calculate correct averages', async () => {
      const summary = await manager.getSummary('day');
      
      if (summary.sessionCount > 0) {
        expect(summary.avgCostPerSession).toBe(summary.totalCost / summary.sessionCount);
      } else {
        expect(summary.avgCostPerSession).toBe(0);
      }
    });
  });

  describe('exportData', () => {
    test('should export data in CSV format', async () => {
      const csvData = await manager.exportData('csv');
      
      expect(typeof csvData).toBe('string');
      expect(csvData).toContain('timestamp');
      expect(csvData).toContain('cost');
    });

    test('should export data in JSON format', async () => {
      const jsonData = await manager.exportData('json');
      
      expect(typeof jsonData).toBe('string');
      expect(() => JSON.parse(jsonData)).not.toThrow();
    });

    test('should export data with date range filter', async () => {
      const startDate = new Date('2025-01-01').getTime();
      const endDate = new Date('2025-01-31').getTime();
      
      const data = await manager.exportData('json', [startDate, endDate]);
      
      expect(typeof data).toBe('string');
      const parsedData = JSON.parse(data);
      expect(Array.isArray(parsedData)).toBe(true);
    });

    test('should complete export within performance requirements (<2s for 30-day periods)', async () => {
      const startDate = new Date('2025-01-01').getTime();
      const endDate = new Date('2025-01-31').getTime();
      
      const startTime = Date.now();
      await manager.exportData('csv', [startDate, endDate]);
      const duration = Date.now() - startTime;
      
      expect(duration).toBeLessThan(2000);
    });
  });

  describe('cleanup', () => {
    test('should remove data older than retention period', async () => {
      const sixMonthsAgo = new Date();
      sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
      
      mockFs.readdir.mockResolvedValueOnce(['2024-01.json', '2025-01.json'] as any);
      mockFs.unlink.mockResolvedValue();
      
      await manager.cleanup();
      
      // Should identify and remove old files
      expect(mockFs.readdir).toHaveBeenCalled();
    });

    test('should preserve recent data during cleanup', async () => {
      const currentMonth = new Date().toISOString().substring(0, 7);
      
      mockFs.readdir.mockResolvedValueOnce([`${currentMonth}.json`] as any);
      
      await manager.cleanup();
      
      // Should not delete current month data
      expect(mockFs.unlink).not.toHaveBeenCalledWith(
        expect.stringContaining(`${currentMonth}.json`)
      );
    });
  });

  describe('performance requirements', () => {
    test('should maintain <10MB memory footprint for 6-month dataset', async () => {
      // This would be measured in actual implementation
      // For now, we ensure the data structure is efficient
      const manager = new AnalyticsManager();
      expect(manager).toBeInstanceOf(AnalyticsManager);
    });

    test('should support lazy loading of historical data', async () => {
      // Test that data is loaded on-demand rather than all at once
      const metrics = await manager.getMetrics(0, Date.now());
      expect(Array.isArray(metrics)).toBe(true);
    });

    test('should cache frequently accessed data', async () => {
      // First call should load data
      await manager.getSummary('day');
      
      // Second call should use cache (faster)
      const startTime = Date.now();
      await manager.getSummary('day');
      const duration = Date.now() - startTime;
      
      expect(duration).toBeLessThan(50); // Should be very fast from cache
    });
  });

  describe('data integrity', () => {
    test('should validate metric data before storing', async () => {
      const invalidMetrics = [
        { ...mockMetric, cost: -1 }, // Negative cost
        { ...mockMetric, inputTokens: -5 }, // Negative tokens
        { ...mockMetric, timestamp: 'invalid' }, // Invalid timestamp
      ];

      for (const invalid of invalidMetrics) {
        await expect(manager.recordMetric(invalid as any)).rejects.toThrow();
      }
    });

    test('should handle file system errors gracefully', async () => {
      mockFs.writeFile.mockRejectedValueOnce(new Error('Disk full'));
      
      await expect(manager.recordMetric(mockMetric)).rejects.toThrow('Disk full');
    });

    test('should maintain data consistency during concurrent operations', async () => {
      const metrics = Array.from({ length: 10 }, (_, i) => ({
        ...mockMetric,
        sessionId: `concurrent-${i}`
      }));

      // Simulate concurrent writes
      const promises = metrics.map(metric => manager.recordMetric(metric));
      await Promise.all(promises);
      
      const allMetrics = await manager.getMetrics(0, Date.now() + 1000);
      expect(allMetrics.length).toBeGreaterThanOrEqual(10);
    });
  });
});

describe('Integration Tests', () => {
  test('CostCalculator and AnalyticsManager should work together', async () => {
    const calculator = new CostCalculator();
    const manager = new AnalyticsManager({ autoSave: false });
    
    // Calculate cost and store metric
    const cost = calculator.calculateCost('copilot', 'gpt-3.5-turbo', 1000, 500);
    
    const metric: CostMetric = {
      timestamp: Date.now(),
      sessionId: 'integration-test',
      model: 'gpt-3.5-turbo',
      inputTokens: 1000,
      outputTokens: 500,
      cost,
      provider: 'copilot',
      duration: 2000
    };
    
    await manager.recordMetric(metric);
    
    const summary = await manager.getSummary('day');
    expect(summary.totalCost).toBeGreaterThan(0);
  });

  test('should handle real-world usage patterns', async () => {
    const calculator = new CostCalculator();
    const manager = new AnalyticsManager({ autoSave: false });
    
    // Simulate a typical session with multiple interactions
    const sessionId = 'real-world-session';
    const interactions = 10;
    
    for (let i = 0; i < interactions; i++) {
      const inputTokens = Math.floor(Math.random() * 1000) + 100;
      const outputTokens = Math.floor(Math.random() * 500) + 50;
      const cost = calculator.calculateCost('copilot', 'gpt-3.5-turbo', inputTokens, outputTokens);
      
      await manager.recordMetric({
        timestamp: Date.now() + (i * 1000),
        sessionId,
        model: 'gpt-3.5-turbo',
        inputTokens,
        outputTokens,
        cost,
        provider: 'copilot',
        duration: Math.floor(Math.random() * 5000) + 1000
      });
    }
    
    const summary = await manager.getSummary('day');
    expect(summary.sessionCount).toBeGreaterThan(0);
    expect(summary.totalCost).toBeGreaterThan(0);
    expect(summary.totalTokens).toBeGreaterThan(0);
  });
});